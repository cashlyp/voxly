"use strict";

/**
 * scriptDesignerCallbacks.js
 *
 * Parses and validates callback_data payloads that belong to the Script Designer
 * family of menus (script-channel, call-script-*, sms-script-*, inbound-default*,
 * email-template-*).
 *
 * ─────────────────────────────────────────────────────────────────────────────
 * BUG FIX — "⚠️ This menu is no longer active." on ALL Script Designer buttons
 * ─────────────────────────────────────────────────────────────────────────────
 *
 * ROOT CAUSE:
 *   SELECTION_PATTERN was `/^\d+$/` — it only accepted pure numeric index tokens
 *   (e.g. "0", "1", "2").
 *
 *   However, buildCallbackReplayQueue() in conversationRecovery.js emits replay-
 *   queue actions with *string* selection IDs:
 *       "script-channel:call"
 *       "call-script-main:list"
 *       "sms-script-main:back"
 *       "inbound-default:set"   etc.
 *
 *   When any of these strings arrived at the global callback router (bot.js),
 *   parseScriptDesignerCallbackAction returned:
 *       { isScriptDesigner: true, valid: false, reason: "invalid_selection_token" }
 *
 *   That caused the router to call safeAnswerCallbackQuery with
 *   "⚠️ Invalid script menu action." — which surfaced to the user as the
 *   "menu is no longer active" alert.
 *
 *   In addition, the same invalid-parse meant getConversationRecoveryTarget()
 *   received a non-normalised action string, causing recovery to sometimes
 *   silently no-op instead of re-entering the scripts-conversation.
 *
 * FIX:
 *   SELECTION_PATTERN extended to `/^(\d+|[a-z][a-z0-9_-]{0,31})$/` so that
 *   both numeric indices AND lowercase keyword ids are accepted as valid
 *   selection tokens.  A new `isStringId` boolean is returned so callers can
 *   distinguish a live button tap (numeric) from a replay-queue action (string).
 */

const SCRIPT_DESIGNER_PREFIX_PATTERNS = [
  /^script-channel$/,
  /^call-script-/,
  /^sms-script-/,
  /^inbound-default/,
  /^email-template-/,
];

const OP_TOKEN_PATTERN = /^[0-9a-fA-F-]{8,}$/;
const NONCE_PATTERN = /^[A-Za-z0-9_-]{1,24}$/;

/**
 * FIX: was /^\d+$/ — now also accepts lowercase keyword ids used in replay
 *      queue entries (e.g. "call", "list", "sms", "incoming", "back", "set").
 */
const SELECTION_PATTERN = /^(\d+|[a-z][a-z0-9_-]{0,31})$/;

function isScriptDesignerPrefix(prefix) {
  const candidate = String(prefix || "");
  return SCRIPT_DESIGNER_PREFIX_PATTERNS.some((pattern) =>
    pattern.test(candidate),
  );
}

/**
 * Returns true when the selection token is a string keyword rather than a
 * numeric index.  String-id tokens come exclusively from replay-queue entries
 * generated by buildCallbackReplayQueue() in conversationRecovery.js.
 */
function isStringSelectionToken(token) {
  return /^[a-z][a-z0-9_-]{0,31}$/.test(String(token || ""));
}

function parseScriptDesignerCallbackAction(action) {
  const rawAction = String(action || "").trim();
  if (!rawAction) {
    return {
      isScriptDesigner: false,
      valid: false,
      reason: "empty_action",
      rawAction,
    };
  }

  const parts = rawAction.split(":").filter((part) => part.length > 0);
  const prefix = parts[0] || "";
  if (!isScriptDesignerPrefix(prefix)) {
    return {
      isScriptDesigner: false,
      valid: false,
      reason: "non_script_prefix",
      rawAction,
      prefix,
    };
  }

  if (parts.length < 2) {
    return {
      isScriptDesigner: true,
      valid: false,
      reason: "missing_selection",
      rawAction,
      prefix,
    };
  }

  const selectionToken = parts[parts.length - 1];

  // FIX: SELECTION_PATTERN now also accepts string keyword ids.
  if (!SELECTION_PATTERN.test(selectionToken)) {
    return {
      isScriptDesigner: true,
      valid: false,
      reason: "invalid_selection_token",
      rawAction,
      prefix,
      selectionToken,
    };
  }

  const middle = parts.slice(1, -1);
  if (middle.length > 2) {
    return {
      isScriptDesigner: true,
      valid: false,
      reason: "unexpected_token_count",
      rawAction,
      prefix,
      selectionToken,
    };
  }
  if (middle.length >= 1 && !OP_TOKEN_PATTERN.test(middle[0])) {
    return {
      isScriptDesigner: true,
      valid: false,
      reason: "invalid_op_token",
      rawAction,
      prefix,
      selectionToken,
      opToken: middle[0],
    };
  }
  if (middle.length === 2 && !NONCE_PATTERN.test(middle[1])) {
    return {
      isScriptDesigner: true,
      valid: false,
      reason: "invalid_nonce",
      rawAction,
      prefix,
      selectionToken,
      nonce: middle[1],
    };
  }

  const normalizedAction = `${prefix}:${selectionToken}`;
  const isStringId = isStringSelectionToken(selectionToken);

  return {
    isScriptDesigner: true,
    valid: true,
    reason: null,
    rawAction,
    prefix,
    selectionToken,
    // selectionIndex is only meaningful for numeric tokens (live button taps).
    // It is null for string-id replay-queue tokens.
    selectionIndex: isStringId ? null : Number(selectionToken),
    // isStringId = true  → replay-queue action (string keyword id)
    // isStringId = false → live button tap (numeric index)
    isStringId,
    normalizedAction,
    opToken:
      middle.length >= 1 ? middle[0].replace(/-/g, "").slice(0, 8) : null,
    nonce: middle.length === 2 ? middle[1] : null,
    legacy: middle.length > 0,
  };
}

function isScriptDesignerAction(action) {
  return parseScriptDesignerCallbackAction(action).isScriptDesigner;
}

module.exports = {
  SCRIPT_DESIGNER_PREFIX_PATTERNS,
  isScriptDesignerPrefix,
  parseScriptDesignerCallbackAction,
  isScriptDesignerAction,
};
